{"version":3,"sources":["node_modules/browser-pack/_prelude.js","peer.js","node_modules/tricks/object/extend.js","node_modules/tricks/object/instanceOf.js","node_modules/tricks/object/pubsub.js","node_modules/tricks/time/setImmediate.js","src/lib/featureDetect.js","src/main.js","src/models/files.js","src/models/localmedia.js","src/models/presence.js","src/models/socket.js","src/models/stream.js","src/models/threads.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","_interopRequireDefault","obj","__esModule","default","extend","_len","arguments","args","Array","_key","forEach","_instanceOf2","Object","x","defineProperty","value","_instanceOf","./instanceOf.js",2,"test","root",3,"on","evt","callback","_this2","this","split","separator","name","events","concat","off","findEvents","index","emit","push","handler","apply","_this","parent","emitAfter","_setImmediate2","hasOwnProperty","indexOf","triggerCallback","bind","utils","_setImmediate","../time/setImmediate.js",4,"window","setImmediate","cb","setTimeout",5,"define","PeerConnection","pc","channel","iceServers","url","createDataChannel","reliable","close","rtc","datachannel",6,"_pubsub","_pubsub2","_extend","_extend2","_featureDetect","_featureDetect2","_socket","_socket2","_presence","_presence2","_threads","_threads2","_stream","_files","_localmedia","STUN_SERVER","peer","create","stun_server","support","Streams","LocalMedia","addEventListener","disconnect","./lib/featureDetect","./models/files","./models/localmedia","./models/presence","./models/socket","./models/stream","./models/threads","tricks/object/extend","tricks/object/pubsub",7,"self","chunkLength","sendFile","file","to","onReadAsDataURL","event","text","target","result","data","message","slice","last","send","remainingDataURL","reader","FileReader","onload","readAsDataURL","type","files","id",8,"getUserMedia","localmedia","addMedia","successHandler","failHandler","_success","stream","EventTarget","audio","video",9,"tag","watch",10,"_typeof","Symbol","iterator","constructor","getScript","callbacks","init","ws","connected","socket","io","connect","console","log","sessionid","JSON","parse","callback_response","from","callback_id","stringify","one","action",11,"RTCSessionDescription","merge","isEqual","Events","Stream","constraints","operation","func","operations","signalingState","op","shift","errorHandler","error","setupDataChannel","debug","onopen","onmessage","onerror","toggleLocalStream","readyState","local","remote","media","getLocalStreams","removeStream","exit","_media","addStream","MASTER","setConstraints","changed","remotemedia","pc_config","pc_constraints","optional","DtlsSrtpKeyAgreement","onicecandidate","candidate","label","sdpMLineIndex","toSdp","onsignalingstatechange","oniceconnectionstatechange","warn","iceConnectionState","onaddstream","onremovestream","ondatachannel","onnegotiationneeded","createOffer","session","setLocalDescription","localDescription","config","open","offer","setRemoteDescription","createAnswer","default_constraints","mandatory","OfferToReceiveAudio","OfferToReceiveVideo","streams","undefined","socketSend","recipient","str","uid","RTCIceCandidate","addIceCandidate","err","mediastream",12,"Thread","state","extendProperties","b","constraint","updatePeerConnection","remoteID","threadId","threads","thread","Math","random","toString"],"mappings":"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","file":"peer.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = extend;\n\nvar _instanceOf = require('./instanceOf.js');\n\nvar _instanceOf2 = _interopRequireDefault(_instanceOf);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction extend(r) {\n\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\targs[_key - 1] = arguments[_key];\n\t}\n\n\targs.forEach(function (o) {\n\t\tif ((0, _instanceOf2.default)(r, Object) && (0, _instanceOf2.default)(o, Object) && r !== o) {\n\t\t\tfor (var x in o) {\n\t\t\t\tr[x] = extend(r[x], o[x]);\n\t\t\t}\n\t\t} else {\n\t\t\tr = o;\n\t\t}\n\t});\n\treturn r;\n}\n\n},{\"./instanceOf.js\":2}],2:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nexports.default = function (test, root) {\n\treturn root && test instanceof root;\n};\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nexports.default = function () {\n\n\t// If this doesn't support getPrototype then we can't get prototype.events of the parent\n\t// So lets get the current instance events, and add those to a parent property\n\tthis.parent = {\n\t\tevents: this.events,\n\t\tfindEvents: this.findEvents,\n\t\tparent: this.parent,\n\t\tutils: this.utils\n\t};\n\n\tthis.events = {};\n\n\tthis.off = off;\n\tthis.on = on;\n\tthis.emit = emit;\n\tthis.emitAfter = emitAfter;\n\tthis.findEvents = findEvents;\n\n\treturn this;\n};\n\nvar _setImmediate = require('../time/setImmediate.js');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar separator = /[\\s\\,]+/; // Pubsub extension\n// A contructor superclass for adding event menthods, on, off, emit.\n\n// On, subscribe to events\n// @param evt   string\n// @param callback  function\nfunction on(evt, callback) {\n\tvar _this2 = this;\n\n\tif (callback && typeof callback === 'function') {\n\t\tevt.split(separator).forEach(function (name) {\n\t\t\t// Has this event already been fired on this instance?\n\t\t\t_this2.events[name] = [callback].concat(_this2.events[name] || []);\n\t\t});\n\t}\n\n\treturn this;\n}\n\n// Off, unsubscribe to events\n// @param evt   string\n// @param callback  function\nfunction off(evt, callback) {\n\n\tthis.findEvents(evt, function (name, index) {\n\t\tif (!callback || this.events[name][index] === callback) {\n\t\t\tthis.events[name][index] = null;\n\t\t}\n\t});\n\n\treturn this;\n}\n\n// Emit\n// Triggers any subscribed events\nfunction emit(evt) {\n\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\targs[_key - 1] = arguments[_key];\n\t}\n\n\t// Append the eventname to the end of the arguments\n\targs.push(evt);\n\n\t// Handler\n\tvar handler = function handler(name, index) {\n\n\t\t// Replace the last property with the event name\n\t\targs[args.length - 1] = name === '*' ? evt : name;\n\n\t\t// Trigger\n\t\tthis.events[name][index].apply(this, args);\n\t};\n\n\t// Find the callbacks which match the condition and call\n\tvar _this = this;\n\twhile (_this && _this.findEvents) {\n\n\t\t// Find events which match\n\t\t_this.findEvents(evt + ',*', handler);\n\t\t_this = _this.parent;\n\t}\n\n\treturn this;\n}\n\n// Easy functions\nfunction emitAfter() {\n\tvar _this = this;\n\tvar args = arguments;\n\t(0, _setImmediate2.default)(function () {\n\t\t_this.emit.apply(_this, args);\n\t});\n\n\treturn this;\n}\n\nfunction findEvents(evt, callback) {\n\n\tvar a = evt.split(separator);\n\n\tfor (var name in this.events) {\n\t\tif (this.events.hasOwnProperty(name)) {\n\n\t\t\tif (a.indexOf(name) > -1) {\n\n\t\t\t\tthis.events[name].forEach(triggerCallback.bind(this, name, callback));\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction triggerCallback(name, callback, handler, i) {\n\t// Does the event handler exist?\n\tif (handler) {\n\t\t// Emit on the local instance of this\n\t\tcallback.call(this, name, i);\n\t}\n}\n\n},{\"../time/setImmediate.js\":4}],4:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = window.setImmediate || function (cb) {\n  return setTimeout(cb, 0);\n};\n\n},{}],5:[function(require,module,exports){\n\"use strict\";\n\ndefine(['../utils/PeerConnection'], function (PeerConnection) {\n\tvar pc, channel;\n\ttry {\n\t\t// raises exception if createDataChannel is not supported\n\t\tpc = new PeerConnection({ \"iceServers\": [{ \"url\": \"stun:localhost\" }] });\n\t\tchannel = pc.createDataChannel('supportCheck', { reliable: false });\n\t\tchannel.close();\n\t\tpc.close();\n\t} catch (e) {}\n\n\treturn {\n\t\trtc: !!pc,\n\t\tdatachannel: !!channel\n\t};\n});\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\n// PeerJS\n// WebRTC Client Controler\n// @author Andrew Dodson (@mr_switch)\n// @since July 2012\n//\n\nvar _pubsub = require('tricks/object/pubsub');\n\nvar _pubsub2 = _interopRequireDefault(_pubsub);\n\nvar _extend = require('tricks/object/extend');\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _featureDetect = require('./lib/featureDetect');\n\nvar _featureDetect2 = _interopRequireDefault(_featureDetect);\n\nvar _socket = require('./models/socket');\n\nvar _socket2 = _interopRequireDefault(_socket);\n\nvar _presence = require('./models/presence');\n\nvar _presence2 = _interopRequireDefault(_presence);\n\nvar _threads = require('./models/threads');\n\nvar _threads2 = _interopRequireDefault(_threads);\n\nvar _stream = require('./models/stream');\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nvar _files = require('./models/files');\n\nvar _files2 = _interopRequireDefault(_files);\n\nvar _localmedia = require('./models/localmedia');\n\nvar _localmedia2 = _interopRequireDefault(_localmedia);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar STUN_SERVER = \"stun:stun.l.google.com:19302\";\nvar peer = Object.create(new _pubsub2.default());\n\n(0, _extend2.default)(peer, {\n\n\t// Defaults\n\tstun_server: STUN_SERVER,\n\n\t// DataChannel\n\tsupport: _featureDetect2.default\n});\n\n// Expose external\nwindow.peer = peer;\n\n// Extend with the Web Sockets methods: connect(), send()\n_socket2.default.call(peer);\n\n// Presence\n// Tag the current session with a unique identifier so that others can be notified about your presense and you can be notified about others\n_presence2.default.call(peer);\n\n// Extend with the thread management: thread(), threads{}\n_threads2.default.call(peer);\n\n// Extend with stream management: stream(), streams{}\nStreams.call(peer);\n\n// Extend with local Media\nLocalMedia.call(peer);\n\n// Extend with File Transfer\n// Files.call(peer);\n\n// BeforeUnload\nwindow.addEventListener('beforeunload', function () {\n\t// Tell everyone else of the session close.\n\tpeer.disconnect();\n});\n\n},{\"./lib/featureDetect\":5,\"./models/files\":7,\"./models/localmedia\":8,\"./models/presence\":9,\"./models/socket\":10,\"./models/stream\":11,\"./models/threads\":12,\"tricks/object/extend\":1,\"tricks/object/pubsub\":3}],7:[function(require,module,exports){\n'use strict';\n\n//\n// File\n// Make available a link to stream file/blob artifacts\n//\n\ndefine([], function () {\n\n\treturn function () {\n\n\t\tvar self = this;\n\n\t\tvar chunkLength = 1000;\n\n\t\t// Extend the peer object\n\t\t// Sends the current file to another peer\n\n\t\tthis.sendFile = function (file, to) {\n\n\t\t\tvar reader = new window.FileReader();\n\n\t\t\treader.onload = onReadAsDataURL;\n\n\t\t\treader.readAsDataURL(file);\n\n\t\t\tvar data = {\n\t\t\t\tto: to,\n\t\t\t\ttype: 'file:progress'\n\t\t\t};\n\n\t\t\tfunction onReadAsDataURL(event, text, index) {\n\n\t\t\t\tif (event) {\n\t\t\t\t\ttext = event.target.result;\n\t\t\t\t}\n\n\t\t\t\tdata.index = +index || 0;\n\n\t\t\t\tif (text.length > chunkLength) {\n\t\t\t\t\tdata.message = text.slice(0, chunkLength); // getting chunk using predefined chunk length\n\t\t\t\t} else {\n\t\t\t\t\t\tdata.message = text;\n\t\t\t\t\t\tdata.last = true;\n\t\t\t\t\t}\n\n\t\t\t\tself.send(data); // use JSON.stringify for chrome!\n\n\t\t\t\tvar remainingDataURL = text.slice(data.message.length);\n\n\t\t\t\tif (remainingDataURL.length) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tonReadAsDataURL(null, remainingDataURL); // continue transmitting\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tvar files = {};\n\n\t\t//\n\t\t// Listen to incoming files\n\t\t//\n\t\tthis.on('file:progress', function (data) {\n\n\t\t\t// Stick the pieces of the file back together\n\t\t\tfiles[data.id] = files[data.id] || [];\n\t\t\tfiles[data.id][data.index] = data.message;\n\t\t});\n\t};\n});\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\n//\n// localMedia\n//\ndefine(['../utils/getUserMedia'], function (getUserMedia) {\n\n\treturn function () {\n\n\t\t//\n\t\t// LocalMedia\n\t\t//\n\t\tthis.localmedia = null;\n\n\t\t//\n\t\t// AddMedia\n\t\t//\n\t\tthis.addMedia = function (successHandler, failHandler) {\n\n\t\t\tvar self = this;\n\n\t\t\t// Create a success callback\n\t\t\t// Fired when the users camera is attached\n\t\t\tvar _success = function _success(stream) {\n\n\t\t\t\t// Attach stream\n\t\t\t\tself.localmedia = stream;\n\n\t\t\t\t// listen for change events on this stream\n\t\t\t\tstream.addEventListener('ended', function () {\n\t\t\t\t\t// Detect the change\n\t\t\t\t\tif (!self.localmedia || self.localmedia === stream) {\n\t\t\t\t\t\tself.emit('localmedia:disconnect', stream);\n\t\t\t\t\t\tself.localmedia = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (successHandler) {\n\t\t\t\t\tsuccessHandler(stream);\n\t\t\t\t}\n\n\t\t\t\t// Vid onload doesn't seem to fire\n\t\t\t\tself.emit('localmedia:connect', stream);\n\t\t\t};\n\n\t\t\t//\n\t\t\t// Has the callback been replaced with a stream\n\t\t\t//\n\t\t\tif (successHandler instanceof EventTarget) {\n\n\t\t\t\t// User aded a media stream\n\t\t\t\t_success(successHandler);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Do we already have an open stream?\n\t\t\telse if (this.localmedia) {\n\t\t\t\t\tif (successHandler) {\n\t\t\t\t\t\tsuccessHandler(this.localmedia);\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// Call it?\n\t\t\tgetUserMedia({ audio: true, video: true }, _success, function (e) {\n\t\t\t\t// Trigger a failure\n\t\t\t\tself.emit('localmedia:failed', e);\n\t\t\t\tfailHandler();\n\t\t\t});\n\n\t\t\treturn this;\n\t\t};\n\t};\n});\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\n//\n// Provide a mechanism for monitoring peer presence\n//\n\ndefine(function () {\n\n\treturn function () {\n\n\t\t/////////////////////////////////////\n\t\t// TAG / WATCH LIST\n\t\t//\n\t\tthis.tag = function (data) {\n\n\t\t\tif (!(data instanceof Array)) {\n\t\t\t\tdata = [data];\n\t\t\t}\n\n\t\t\tthis.send('presence:tag', { data: data });\n\n\t\t\treturn this;\n\t\t};\n\n\t\t//\n\t\t// Add and watch personal identifications\n\t\t//\n\t\tthis.watch = function (data) {\n\n\t\t\tif (!(data instanceof Array)) {\n\t\t\t\tdata = [data];\n\t\t\t}\n\n\t\t\tthis.send('presence:watch', { to: data });\n\n\t\t\treturn this;\n\t\t};\n\t};\n});\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n//\n// Web Socket\n// Socket creates a send/receive protocol with the server\n// Currently this abstracts Socket.IO\n//\ndefine(['../utils/getScript'], function (getScript) {\n\n\tvar callbacks = [];\n\n\treturn function () {\n\n\t\tvar self = this;\n\n\t\t//\n\t\t// Initiate the socket connection\n\t\t//\n\t\tthis.init = function (ws, callback) {\n\n\t\t\t//\n\t\t\tvar connected;\n\n\t\t\t// What happens on connect\n\t\t\tvar onload = function onload() {\n\n\t\t\t\tif (connected) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconnected = false;\n\n\t\t\t\t// Connect to the socket\n\t\t\t\tsocket = io.connect(ws);\n\n\t\t\t\tconsole.log(socket.socket.sessionid);\n\n\t\t\t\t// Define an message handling\n\t\t\t\tsocket.on('message', function (data) {\n\n\t\t\t\t\t// Deserialize\n\t\t\t\t\tdata = JSON.parse(data);\n\n\t\t\t\t\t// Look for callbacks\n\t\t\t\t\tif (\"callback_response\" in data) {\n\t\t\t\t\t\tvar i = data.callback_response;\n\t\t\t\t\t\tdelete data.callback_response;\n\t\t\t\t\t\tcallbacks[i](data);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tself.emit.call(self, data.type, data, function (o) {\n\t\t\t\t\t\t// if callback was defined, lets send it back\n\t\t\t\t\t\tif (\"callback_id\" in data) {\n\t\t\t\t\t\t\to.to = data.from;\n\t\t\t\t\t\t\to.callback_response = data.callback_id;\n\t\t\t\t\t\t\tsocket.send(JSON.stringify(o));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t// Load SocketIO if it doesn't exist\n\t\t\tif (typeof io === 'undefined') {\n\t\t\t\tgetScript((ws || '') + \"/socket.io/socket.io.js\", onload);\n\t\t\t}\n\n\t\t\t// Loaded\n\t\t\tif (callback) {\n\t\t\t\tthis.one('socket:connect', callback);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t// Disconnect\n\n\t\tthis.disconnect = function () {\n\t\t\tif (socket) {\n\t\t\t\tsocket.disconnect();\n\t\t\t}\n\t\t};\n\n\t\t//\n\t\t// Send information to the socket\n\t\t//\n\t\tthis.send = function (name, data, callback) {\n\n\t\t\t//\n\t\t\tif ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n\t\t\t\tcallback = data;\n\t\t\t\tdata = name;\n\t\t\t\tname = data.type;\n\t\t\t} else {\n\t\t\t\tdata.type = name;\n\t\t\t}\n\n\t\t\tvar callback_id;\n\n\t\t\t// Add callback\n\t\t\tif (callback) {\n\t\t\t\t// Count\n\t\t\t\tdata.callback_id = callbacks.length;\n\t\t\t\tcallbacks.push(callback);\n\t\t\t}\n\n\t\t\tvar action = function action() {\n\t\t\t\tconsole.log(\"sending:\", data);\n\t\t\t\tsocket.send(JSON.stringify(data));\n\t\t\t};\n\n\t\t\tif (this.id) {\n\t\t\t\taction();\n\t\t\t} else {\n\t\t\t\tself.one('socket:connect', action);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\tself.one('socket:connect', function (e) {\n\t\t\tself.id = e.id;\n\t\t});\n\t};\n});\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n//\n// Stream\n// Create a new PeerConnection\n//\n\ndefine(['../utils/PeerConnection', '../utils/RTCSessionDescription', '../utils/extend', '../utils/merge', '../utils/isEqual', '../utils/events'], function (PeerConnection, RTCSessionDescription, extend, merge, isEqual, Events) {\n\n\t// Default Constraints\n\tvar default_constraints = {\n\t\tvideo: false\n\t};\n\n\tvar config = { 'optional': [], 'mandatory': {\n\t\t\t'OfferToReceiveAudio': true,\n\t\t\t'OfferToReceiveVideo': true } };\n\n\tvar media;\n\n\t// Extend our Global object with the stream methods, collections and listeners\n\n\treturn function () {\n\n\t\t// A collection of Peer Connection streams\n\n\t\tthis.streams = {};\n\n\t\t// Stream\n\t\t// Establishes a connection with a user\n\n\t\tthis.stream = function (id, constraints, offer) {\n\n\t\t\tconsole.log(\"stream\", arguments);\n\n\t\t\tif (!id) {\n\t\t\t\tthrow 'streams(): Expecting an ID';\n\t\t\t}\n\n\t\t\t// Does this stream exist?\n\t\t\tvar stream = this.streams[id];\n\n\t\t\tif (!stream) {\n\n\t\t\t\t// Create a new stream\n\t\t\t\tstream = this.streams[id] = Stream(id, constraints, this.stun_server, this);\n\n\t\t\t\t// Update an existing stream with fresh constraints\n\t\t\t\tif (constraints) {\n\t\t\t\t\tstream.setConstraints(constraints);\n\t\t\t\t}\n\n\t\t\t\t// Output pupblished events from this stream\n\t\t\t\tstream.on('*', this.emit.bind(this));\n\n\t\t\t\t// Control\n\t\t\t\t// This should now work, will have to reevaluate\n\t\t\t\tthis.on('localmedia:connect', stream.addStream);\n\t\t\t\tthis.on('localmedia:disconnect', stream.removeStream);\n\n\t\t\t\t//\n\t\t\t\t// Add the current Stream\n\t\t\t\tif (this.localmedia) {\n\t\t\t\t\tstream.addStream(this.localmedia);\n\t\t\t\t}\n\n\t\t\t\t// intiiate the PeerConnection controller\n\t\t\t\t// Add the offer to the stream\n\t\t\t\tstream.open(offer || null);\n\n\t\t\t\treturn stream;\n\t\t\t} else if (constraints) {\n\n\t\t\t\t// Update an existing stream with fresh constraints\n\t\t\t\tstream.setConstraints(constraints);\n\t\t\t} else if (offer !== undefined) {\n\t\t\t\tstream.open(offer);\n\t\t\t}\n\n\t\t\treturn stream;\n\t\t};\n\n\t\t//////////////////////////////////////////////////\n\t\t// CHANNEL MESSAGING\n\t\t//////////////////////////////////////////////////\n\n\t\t// Store the socket send function\n\t\tvar socketSend = this.send;\n\n\t\t// Change it\n\t\tthis.send = function (name, data, callback) {\n\n\t\t\tif ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n\t\t\t\tcallback = data;\n\t\t\t\tdata = name;\n\t\t\t\tname = data.type;\n\t\t\t}\n\n\t\t\tvar recipient = data.to,\n\t\t\t    stream = this.streams[recipient];\n\n\t\t\tif (recipient && stream && stream.channel && stream.channel.readyState === \"open\") {\n\t\t\t\tif (name) {\n\t\t\t\t\tdata.type = name;\n\t\t\t\t}\n\t\t\t\tvar str = JSON.stringify(data);\n\t\t\t\ttry {\n\t\t\t\t\tstream.channel.send(str);\n\t\t\t\t\treturn;\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\t// Other party could have disappeared\n\t\t\t\t\t// code: 19\n\t\t\t\t\t// message: \"Failed to execute 'send' on 'RTCDataChannel': Could not send data\"\n\t\t\t\t\t// name: \"NetworkError\"\n\n\t\t\t\t\tstream.channel = null;\n\n\t\t\t\t\t// Retrigger the stream channel creation\n\n\t\t\t\t\tthis.stream(recipient, null, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Else fallback to the socket method\n\t\t\tsocketSend.call(this, name, data, callback);\n\t\t};\n\n\t\t//////////////////////////////////////////////////\n\t\t// STREAMS\n\t\t//////////////////////////////////////////////////\n\n\t\t// stream:connect\n\t\t// pass through any stream connection events\n\n\t\tthis.on('stream:connect, stream:change, stream:constraints', function (e) {\n\n\t\t\t// What has changed\n\t\t\tvar constraints = {};\n\n\t\t\t// we have information on what the remote constraints are\n\t\t\tif (e.remote) {\n\t\t\t\tconstraints.remote = merge(default_constraints, e.remote);\n\t\t\t}\n\t\t\t// We have the local constraints\n\t\t\t// Let also check that this has no-from field\n\t\t\tif (e.local && !e.from) {\n\t\t\t\tconstraints.local = merge(default_constraints, e.local);\n\t\t\t}\n\n\t\t\t// Create/Update the stream with the constraints offered.\n\t\t\tthis.stream(e.from || e.id, constraints);\n\t\t});\n\n\t\t// stream:offer\n\t\t// A client has sent a Peer Connection Offer\n\t\t// An Offer Object:\n\t\t//  -  string: SDP packet,\n\t\t//  -  string array: contraints\n\n\t\tthis.on('stream:offer, stream:makeoffer', function (e) {\n\n\t\t\t// Creates a stream:answer event\n\t\t\tthis.stream(e.from, null, e.data || null);\n\t\t});\n\n\t\t//\n\t\t// stream:answer\n\t\t//\n\t\tthis.on('stream:answer', function (e) {\n\n\t\t\tconsole.log(\"on:answer: Answer recieved, connection created\");\n\t\t\tthis.streams[e.from].pc.setRemoteDescription(new RTCSessionDescription(e.data));\n\t\t});\n\n\t\t//\n\t\t// Relay ice Candidates\n\t\t//\n\n\t\tthis.on('stream:candidate', function (e) {\n\n\t\t\tvar uid = e.from,\n\t\t\t    data = e.data,\n\t\t\t    stream = this.streams[uid];\n\n\t\t\tif (!stream) {\n\t\t\t\tconsole.error(\"Candidate needs initiation\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar candidate = new RTCIceCandidate({\n\t\t\t\tsdpMLineIndex: data.label,\n\t\t\t\tcandidate: data.candidate\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tstream.pc.addIceCandidate(candidate);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error('Failed to set iceCandidate');\n\t\t\t\tconsole.error(candidate);\n\t\t\t\tconsole.error(err);\n\t\t\t}\n\t\t});\n\n\t\t// Listen to change to the local media, and remove it streams if this occurs\n\n\t\tthis.on('localmedia:disconnect', function (mediastream) {\n\t\t\t// Loop through streams and call removeStream\n\t\t\tfor (var x in this.streams) {\n\t\t\t\tthis.streams[x].pc.removeStream(mediastream);\n\t\t\t}\n\t\t});\n\n\t\t// Channels\n\t\tthis.on('channel:connect', function (e) {\n\t\t\t//\n\t\t\t// Process\n\t\t\t// console.log('channel:connect',e);\n\t\t});\n\n\t\t//\n\t\tthis.on('channel:message', function (data) {\n\n\t\t\tif (\"callback_response\" in data) {\n\t\t\t\tvar i = data.callback_response;\n\t\t\t\tdelete data.callback_response;\n\t\t\t\tthis.callback[i].call(peer, data);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar type = data.type;\n\n\t\t\tthis.emit(type, data, function (o) {\n\t\t\t\t// if callback was defined, lets send it back\n\t\t\t\tif (\"callback\" in data) {\n\t\t\t\t\to.to = data.from;\n\t\t\t\t\to.callback_response = data.callback;\n\t\t\t\t\tthis.send(o);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\t// ////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// Individual stream controller\n\t//\n\t//\n\t// ////////////////////////////////////////////////////////////\n\n\tfunction Stream(id, constraints, STUN_SERVER, peer) {\n\n\t\t// Operations\n\t\t// Once the RTCPeerConnection object has been initialized, for every call to createOffer, setLocalDescription, createAnswer and setRemoteDescription; execute the following steps:\n\t\t// Append an object representing the current call being handled (i.e. function name and corresponding arguments) to the operations array.\n\t\t// If the length of the operations array is exactly 1, execute the function from the front of the queue asynchronously.\n\t\t// When the asynchronous operation completes (either successfully or with an error), remove the corresponding object from the operations array.\n\t\t//  - After removal, if the array is non-empty, execute the first object queued asynchronously and repeat this step on completion.\n\n\t\tvar operations = [];\n\t\tfunction operation(func) {\n\n\t\t\t// Add operations to the list\n\t\t\tif (func) {\n\t\t\t\toperations.push(func);\n\t\t\t} else {\n\t\t\t\tconsole.log(\"STATE:\", pc.signalingState);\n\t\t\t}\n\n\t\t\t// Are we in a stable state?\n\t\t\tif (pc.signalingState === 'stable') {\n\n\t\t\t\t// Pop the operation off the front.\n\t\t\t\tvar op = operations.shift();\n\t\t\t\tif (op) {\n\t\t\t\t\top();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(\"PENDING:\", operations);\n\t\t\t}\n\t\t}\n\n\t\tvar pc,\n\t\t    stream = new Events();\n\n\t\t// Creating an offer is a little fraught with dnager if the other party does so too\n\t\t// To mitigate the problems lets turn on a flag when the master client (determined arbitarily from session ID)\n\t\t// Needs a negotiation that they wont process offers themselves\n\t\tvar MASTER = id < peer.id;\n\n\t\t// Null\n\t\tstream.channel = null;\n\n\t\t// Default constraints\n\t\tstream.constraints = {\n\t\t\tremote: {},\n\t\t\tlocal: {}\n\t\t};\n\n\t\t// listen to stream change events\n\t\tstream.setConstraints = function (constraints) {\n\n\t\t\t// If changes to the local constraint has occured\n\t\t\t// deliver these to the other peer\n\t\t\tvar changed;\n\t\t\tif (constraints.local && !isEqual(stream.constraints.local, constraints.local)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\n\t\t\t// Update constraints\n\t\t\textend(stream.constraints, constraints || {});\n\n\t\t\tconsole.log(stream.constraints);\n\n\t\t\t// Trigger Constraints/Media changed listener\n\t\t\ttoggleLocalStream();\n\n\t\t\t// Has the local constraints changed?\n\t\t\tif (changed) {\n\t\t\t\t// Tell the thirdparty about it\n\t\t\t\tpeer.send({\n\t\t\t\t\ttype: 'stream:constraints',\n\t\t\t\t\tremote: stream.constraints.local,\n\t\t\t\t\tto: id\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// Listen out for stream:disconnected\n\t\t// this is triggered by the ICE candidate state change\n\t\t// It can be used to infer that the connection has dissappeared\n\t\t// We can use it to disable a media stream\n\t\tstream.on('stream:disconnected', function () {\n\n\t\t\t// Has a remotemedia value been proffered\n\t\t\tif (stream.remotemedia) {\n\n\t\t\t\t// Mimic the removal of the media\n\t\t\t\tstream.emit('media:disconnect', stream.remotemedia);\n\n\t\t\t\t// Reinstate it if the connection is reestablished\n\t\t\t\tstream.one('stream:connected', function () {\n\t\t\t\t\tstream.emit('media:connect', stream.remotemedia);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// Peer Connection\n\t\t// Initiate a local peer connection handler\n\t\tvar pc_config = { \"iceServers\": [{ \"url\": STUN_SERVER }] },\n\t\t    pc_constraints = { \"optional\": [{ \"DtlsSrtpKeyAgreement\": true }] };\n\t\t//\t\t\t\tstun = local ? null : Peer.stun_server;\n\n\t\ttry {\n\t\t\t//\n\t\t\t// Reference this connection\n\t\t\t//\n\t\t\tstream.pc = pc = new PeerConnection(pc_config, pc_constraints);\n\n\t\t\tpc.onicecandidate = function (e) {\n\t\t\t\tvar candidate = e.candidate;\n\t\t\t\tif (candidate) {\n\t\t\t\t\tpeer.send({\n\t\t\t\t\t\ttype: 'stream:candidate',\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tlabel: candidate.label || candidate.sdpMLineIndex,\n\t\t\t\t\t\t\tcandidate: candidate.toSdp ? candidate.toSdp() : candidate.candidate\n\t\t\t\t\t\t},\n\t\t\t\t\t\tto: id\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (e) {\n\t\t\tconsole.error(\"PeerJS: Failed to create PeerConnection, exception: \" + e.message);\n\t\t\treturn stream;\n\t\t}\n\n\t\tpc.onsignalingstatechange = function (e) {\n\t\t\toperation();\n\t\t};\n\n\t\tpc.oniceconnectionstatechange = function (e) {\n\t\t\tconsole.warn(\"ICE-CONNECTION-STATE-CHANGE \" + pc.iceConnectionState);\n\n\t\t\t// Determine whether the third party has ended their connection\n\t\t\tstream.emit('stream:' + pc.iceConnectionState, {\n\t\t\t\tfrom: id\n\t\t\t});\n\t\t};\n\n\t\t//pc.addEventListener(\"addstream\", works in Chrome\n\t\t//pc.onaddstream works in FF and Chrome\n\t\tpc.onaddstream = function (e) {\n\t\t\te.from = id;\n\t\t\tstream.emit('media:connect', e);\n\n\t\t\tstream.remotemedia = e;\n\n\t\t\t// Listen to ended event\n\t\t\t/*\te.stream.addEventListener('ended', function(){\n   \t\talert('ended');\n   \t});*/\n\n\t\t\t// Check to see if they are accepting video\n\t\t\ttoggleLocalStream();\n\t\t};\n\n\t\t// pc.addEventListener(\"removestream\", works in Chrome\n\t\t// pc.onremovestream works in Chrome and FF.\n\t\tpc.onremovestream = function (e) {\n\n\t\t\tremotemedia = null;\n\t\t\te.from = id;\n\t\t\tstream.emit('media:disconnect', e);\n\n\t\t\t// Check to see if they are accepting video\n\t\t\ttoggleLocalStream();\n\t\t};\n\n\t\tpc.ondatachannel = function (e) {\n\t\t\tstream.channel = e.channel;\n\t\t\tsetupDataChannel(e.channel);\n\t\t};\n\n\t\tpc.onnegotiationneeded = function (e) {\n\n\t\t\t// Has the signalling state changed?\n\n\t\t\tif (pc.signalingState === 'closed') {\n\t\t\t\tconsole.warn('signallingState closed');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (MASTER) {\n\n\t\t\t\t// Create an offer\n\t\t\t\tpc.createOffer(function (session) {\n\t\t\t\t\toperation(function () {\n\t\t\t\t\t\tpc.setLocalDescription(session, function () {\n\t\t\t\t\t\t\tpeer.send({\n\t\t\t\t\t\t\t\ttype: \"stream:offer\",\n\t\t\t\t\t\t\t\tto: id,\n\t\t\t\t\t\t\t\tdata: pc.localDescription\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, errorHandler);\n\t\t\t\t\t});\n\t\t\t\t}, null, config);\n\t\t\t} else {\n\n\t\t\t\t// Ask the other client to make the offer\n\t\t\t\tpeer.send({\n\t\t\t\t\ttype: \"stream:makeoffer\",\n\t\t\t\t\tto: id\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tstream.addStream = function (_media) {\n\t\t\tmedia = _media;\n\t\t\ttoggleLocalStream();\n\t\t};\n\n\t\tstream.removeStream = function () {\n\t\t\tmedia = null;\n\t\t\ttoggleLocalStream();\n\t\t};\n\n\t\tstream.open = function (offer) {\n\n\t\t\t// Is this an offer or an answer?\n\t\t\t// No data is needed to make an offer\n\t\t\t// Making an offer?\n\t\t\tif (!offer) {\n\n\t\t\t\t// Trigger onnegotiation needed\n\t\t\t\tif (MASTER && !stream.channel) {\n\t\t\t\t\t// Create a datachannel\n\t\t\t\t\t// This initiates the onnegotiationneeded event\n\t\t\t\t\tstream.channel = pc.createDataChannel('data');\n\t\t\t\t\tsetupDataChannel(stream.channel);\n\t\t\t\t} else {\n\t\t\t\t\t// trigger the fallback for on negotiation needed\n\t\t\t\t\toperation(pc.onnegotiationneeded);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// No, we're processing an offer to make an answer then\n\t\t\t// If this client has protected itself then the third party clients offer is disgarded\n\t\t\telse {\n\t\t\t\t\t// if(!PROTECTED){\n\n\t\t\t\t\t// Set the remote offer information\n\t\t\t\t\tpc.setRemoteDescription(new RTCSessionDescription(offer), function () {\n\n\t\t\t\t\t\tif (pc.signalingState === 'closed') {\n\t\t\t\t\t\t\tconsole.warn(\"signalingState closed: during setRemoteDescription\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpc.createAnswer(function (session) {\n\t\t\t\t\t\t\tconsole.log(\"pc.signalingState\", pc.signalingState);\n\n\t\t\t\t\t\t\tif (pc.signalingState === 'closed') {\n\t\t\t\t\t\t\t\tconsole.warn(\"signalingState closed: after createAnswer\");\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpc.setLocalDescription(session, function () {\n\t\t\t\t\t\t\t\tpeer.send({\n\t\t\t\t\t\t\t\t\ttype: \"stream:answer\",\n\t\t\t\t\t\t\t\t\tto: id,\n\t\t\t\t\t\t\t\t\tdata: pc.localDescription\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}, errorHandler);\n\t\t\t\t\t\t}, null, config);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t};\n\n\t\treturn stream;\n\n\t\tfunction errorHandler(e) {\n\t\t\tconsole.error(\"SET Description failed triggered:\", e);\n\t\t}\n\n\t\t//\n\t\tfunction setupDataChannel(channel) {\n\n\t\t\tconsole.debug(\"DATACHANNEL CREATED\", channel);\n\n\t\t\t// Broadcast\n\t\t\tchannel.onopen = function (e) {\n\t\t\t\tstream.emit(\"channel:connect\", {\n\t\t\t\t\ttype: 'channel:connect',\n\t\t\t\t\tid: id,\n\t\t\t\t\tfrom: id,\n\t\t\t\t\tto: peer.id,\n\t\t\t\t\ttarget: e\n\t\t\t\t});\n\t\t\t};\n\t\t\tchannel.onmessage = function (e) {\n\n\t\t\t\tvar data = JSON.parse(e.data);\n\t\t\t\tdata.from = id;\n\t\t\t\tdata.to = peer.id;\n\t\t\t\tdata.target = e;\n\n\t\t\t\tstream.emit(\"channel:message\", data);\n\t\t\t};\n\t\t\tchannel.onerror = function (e) {\n\t\t\t\te.id = id;\n\t\t\t\tstream.emit(\"channel:error\", e);\n\t\t\t};\n\t\t}\n\n\t\tfunction toggleLocalStream() {\n\n\t\t\tif (!pc || pc.readyState === 'closed') {\n\t\t\t\tconsole.log(\"PC:connection closed, can't add stream\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Do the constraints allow for media to be added?\n\t\t\tif (!stream.constraints.local.video || !stream.constraints.remote.video || !media) {\n\n\t\t\t\t// We should probably remove the stream here\n\t\t\t\tpc.getLocalStreams().forEach(function (media) {\n\t\t\t\t\toperation(function () {\n\t\t\t\t\t\tconsole.log(\"PC:removing local media\", media);\n\t\t\t\t\t\tpc.removeStream(media);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconsole.log(\"PC:adding local media\");\n\n\t\t\t// Has the media already been added?\n\t\t\tvar exit = false;\n\t\t\tpc.getLocalStreams().forEach(function (_media) {\n\t\t\t\tif (media === _media) {\n\t\t\t\t\texit = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (exit) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set up listeners when tracks are removed from this stream\n\t\t\t// Aka if the streams loses its audio/video track we want this to update this peer connection stream\n\t\t\t// For some reason it doesn't... which is weird\n\t\t\t// TODO: remove the any tracks from the stream here if this is not a regular call.\n\t\t\toperation(function () {\n\t\t\t\t// We should probably remove the stream here\n\t\t\t\tconsole.log(\"Adding local stream\");\n\t\t\t\tpc.addStream(media);\n\t\t\t});\n\n\t\t\t// Add event listeners to stream\n\t\t\tmedia.addEventListener('addtrack', function (e) {\n\t\t\t\t// reestablish a track\n\t\t\t\tconsole.log(e);\n\t\t\t\t// Swtich out current stream with new stream\n\t\t\t\t//var a = pc.getLocalStreams();\n\t\t\t\t//console.log(a);\n\t\t\t});\n\n\t\t\t// Remove track\n\t\t\tmedia.addEventListener('removetrack', function (e) {\n\t\t\t\t//var a = pc.getLocalStreams();\n\t\t\t\tconsole.log(e);\n\t\t\t});\n\t\t}\n\t}\n});\n\n},{}],12:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n//\n// Threads\n// Maintain a list of threads which a user is subscribed too\n//\ndefine(['../utils/extend'], function (extend) {\n\n\t// A thread is a collection of the following\n\n\tfunction Thread(id) {\n\t\tthis.id = id;\n\t\tthis.constraints = {};\n\t\tthis.streams = {};\n\t\tthis.state = 'connect';\n\t}\n\n\t// Extention of the peer object\n\n\treturn function () {\n\n\t\t//\n\t\t// A collection of threads for which this user has connected\n\t\tthis.threads = {};\n\n\t\t//\n\t\t// Thread connecting/changeing/disconnecting\n\t\t// Control the participation in a thread, by setting the permissions which you grant the thread.\n\t\t// e.g.\n\t\t// thread( id string, Object[video:true] )  - send 'thread:connect'\t\t- connects this user to a thread. Broadcasts\n\t\t// thread( id string, Object[video:false] ) - send 'thread:change'\t\t- connects/selects this user to a thread\n\t\t// thread( id string, false )\t\t\t\t- send 'thread:disconnect'\t- disconnects this user from a thread\n\t\t//\n\t\t//\n\t\t// Typical preceeding flow: init\n\t\t// -----------------------------\n\t\t// 1. Broadcasts thread:connect + credentials - gets other members thread:connect (incl, credentials)\n\t\t//\n\t\t// 2. Receiving a thread:connect with the users credentials\n\t\t//\t\t- creates a peer connection (if preferential session)\n\t\t//\n\t\t//\t\t- taking the lowest possible credentials of both members decide whether to send camera*\n\t\t//\n\t\t// Thread:change\n\t\t// -----------------------------\n\t\t// 1. Updates sessions, updates other members knowledge of this client\n\t\t//\t\t- Broadcasts thread:change + new credentials to other members.\n\t\t//\t\t- ForEach peer connection which pertains to this session\n\t\t//\t\t\tFor all the threads which this peer connection exists in determine the highest possible credentials, e.g. do they support video\n\t\t//\t\t\tAdd/Remove remote + local video streams (depending on credentials). Should we reignite the Connection confifuration?\n\t\t//\t\t- This looks at all sessions in the thread and determines whether its saf\n\t\t//\n\t\tthis.thread = function (id, constraints) {\n\n\t\t\tvar init = false;\n\n\t\t\tif ((typeof id === 'undefined' ? 'undefined' : _typeof(id)) === \"object\" || !id) {\n\t\t\t\tif (!constraints) {\n\t\t\t\t\tconstraints = id || {};\n\t\t\t\t}\n\n\t\t\t\t// Make up a new thread ID if one wasn't given\n\t\t\t\tid = (Math.random() * 1e18).toString(36);\n\t\t\t}\n\n\t\t\t// Get the thread\n\t\t\tvar thread = this.threads[id];\n\n\t\t\t// Type\n\t\t\tvar type;\n\n\t\t\t// INIT\n\t\t\t// Else intiiatlize the thread\n\t\t\tif (!thread) {\n\n\t\t\t\t// Create the thread object\n\t\t\t\tthread = this.threads[id] = new Thread(id);\n\t\t\t\tthread.constraints = constraints || {};\n\n\t\t\t\t// Response\n\t\t\t\ttype = \"thread:connect\";\n\t\t\t}\n\n\t\t\t// CHANGE constraints\n\t\t\telse if (constraints) {\n\n\t\t\t\t\t// If this had been deleted\n\t\t\t\t\tif (!thread.constraints) {\n\t\t\t\t\t\t// reinstate it\n\t\t\t\t\t\tthread.constraints = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update thread constraints\n\t\t\t\t\textend(thread.constraints, constraints);\n\n\t\t\t\t\t// Response\n\t\t\t\t\ttype = \"thread:change\";\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// DISCONNECT\n\t\t\t\telse if (constraints === false) {\n\n\t\t\t\t\t\t// Update state\n\t\t\t\t\t\tthread.constraints = false;\n\t\t\t\t\t\ttype = \"thread:disconnect\";\n\t\t\t\t\t}\n\n\t\t\tif (type) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tthread: id\n\t\t\t\t};\n\n\t\t\t\t// Constraints changed?\n\t\t\t\tif (constraints) {\n\t\t\t\t\tdata.constraints = thread.constraints;\n\t\t\t\t}\n\n\t\t\t\t// Connect to a messaging group\n\t\t\t\tthis.send(type, data);\n\n\t\t\t\t// Triggered locally\n\t\t\t\tthis.emit(type, data);\n\t\t\t}\n\n\t\t\treturn thread;\n\t\t};\n\n\t\t//\n\t\t// Thread:Connect (comms)\n\t\t// When a user B has joined a thread the party in that thread A is notified with a thread:connect Event\n\t\t// Party A replies with an identical thread:connect to party B (this ensures everyone connecting is actually online)\n\t\t// Party B does not reply to direct thread:connect containing a \"to\" field events, and the chain is broken.\n\t\t//\n\t\tthis.on('thread:connect, thread:change', function (e) {\n\n\t\t\t// The incoming user\n\n\t\t\tvar remoteID = e.from;\n\n\t\t\tconsole.log(\"thread:change\", e);\n\n\t\t\t// Must include a thread id.\n\t\t\t// If this was triggered locally, it wont include the e.from field\n\n\t\t\tif (!e.thread) {\n\t\t\t\t// this is nonsense\n\t\t\t\tthrow Error(\"thread:* event fired without a thread value\");\n\t\t\t}\n\n\t\t\t// Get or create a thread\n\t\t\t// But it could be that the thread was somehow removed.\n\n\t\t\tvar thread = this.thread(e.thread);\n\n\t\t\tif (!remoteID) {\n\n\t\t\t\t// this is a local update\n\t\t\t\t// let all the streams in the thread know\n\t\t\t\tfor (remoteID in thread.streams) {\n\t\t\t\t\tupdatePeerConnection.call(this, remoteID);\n\t\t\t\t}\n\n\t\t\t\t// Lets not do anything.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Establish/Update a session for the thread\n\n\t\t\tif (!(remoteID in thread.streams)) {\n\n\t\t\t\t// Set the default\n\t\t\t\tthread.streams[remoteID] = e.constraints || {};\n\t\t\t} else {\n\t\t\t\t// The stream object contains the constraints for that user\n\t\t\t\t// Lets apply the constraints from this connection too that user.\n\t\t\t\textend(thread.streams[remoteID], e.constraints || {});\n\t\t\t}\n\n\t\t\t// Trigger a review of this peer connection\n\t\t\tupdatePeerConnection.call(this, remoteID);\n\n\t\t\t// SEND THREAD:CONNECT\n\t\t\t// Was this a direct message?\n\t\t\tif (!e.to) {\n\t\t\t\t// Send a thread:connect back to the remote\n\t\t\t\tvar data = {\n\t\t\t\t\tto: remoteID,\n\t\t\t\t\tthread: thread.id,\n\t\t\t\t\tconstraints: thread.constraints\n\t\t\t\t};\n\t\t\t\tconsole.log(\"SEND\", JSON.stringify(data));\n\t\t\t\tthis.send('thread:connect', data);\n\t\t\t}\n\t\t});\n\n\t\t// thread:disconnect\n\t\t// When a member disconnects from a thread we get a thread:disconnect event\n\n\t\tthis.on('thread:disconnect', function (e) {\n\n\t\t\t// Get thread\n\t\t\tvar thread = this.threads[e.thread];\n\t\t\tvar remoteID;\n\n\t\t\t// Is from a remote peer\n\t\t\tif (\"from\" in e) {\n\n\t\t\t\tremoteID = e.from;\n\n\t\t\t\t// From a remote peer removing their thread connection\n\t\t\t\tif (remoteID in thread.streams) {\n\n\t\t\t\t\tdelete thread.streams[remoteID];\n\n\t\t\t\t\t// Clean up sessions\n\t\t\t\t\tupdatePeerConnection.call(this, remoteID);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// From the local peer, removing themselves from a thread\n\t\t\telse {\n\n\t\t\t\t\t// Loop through the thread streams\n\t\t\t\t\tfor (remoteID in threads.stream) {\n\n\t\t\t\t\t\t// Clean up peer connection\n\t\t\t\t\t\tupdatePeerConnection.call(this, remoteID);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t});\n\n\t\t// For all the active peers pertaining to multiple threads, determine whether the connection setting have changed.\n\t\t//\n\t\t// This is done my looping through all threads to find the session for a particular peer\n\t\t// Building a list of the maximum constraint connection requirements for that remote peer.\n\t\t// Whilst building a maximum constraints for the local peer for where the remote peer is in the same thread.\n\t\t// Trigger a stream:change event with the constraints from the aforementioned two maxiumm requirements\n\n\t\tfunction updatePeerConnection(remoteID) {\n\n\t\t\t// Placeholder to store the minimal requirement for this peer\n\n\t\t\tvar local = {},\n\t\t\t    remote = {};\n\n\t\t\t// Start looping through the threads\n\t\t\t// And then the streams\n\n\t\t\tfor (var threadId in this.threads) {\n\n\t\t\t\tvar thread = this.threads[threadId];\n\t\t\t\tvar streams = thread.streams;\n\n\t\t\t\t// Is this peer not associated with the current thread\n\t\t\t\tif (!(remoteID in streams)) {\n\t\t\t\t\t// Look at the next thread\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// REMOTE\n\t\t\t\textendProperties(remote, streams[remoteID]);\n\n\t\t\t\t// LOCAL\n\t\t\t\textendProperties(local, thread.constraints);\n\t\t\t}\n\n\t\t\t// Once all the stream credentials have been scooped up...\n\t\t\t// Emit a stream:change event\n\t\t\tthis.emit('stream:change', {\n\t\t\t\tid: remoteID,\n\t\t\t\tlocal: local,\n\t\t\t\tremote: remote\n\t\t\t});\n\t\t}\n\t};\n\n\tfunction extendProperties(a, b) {\n\n\t\tif (!b) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var constraint in b) {\n\n\t\t\tvar value = b[constraint];\n\n\t\t\t// If the constraint is true\n\t\t\tif (value) {\n\n\t\t\t\t// Update a\n\t\t\t\ta[constraint] = value;\n\t\t\t}\n\t\t}\n\t}\n});\n\n},{}]},{},[6])\n\n","import instanceOf from './instanceOf.js';\n\nexport default function extend(r, ...args) {\n\targs.forEach(o => {\n\t\tif (instanceOf(r, Object) && instanceOf(o, Object) && r !== o) {\n\t\t\tfor (let x in o) {\n\t\t\t\tr[x] = extend(r[x], o[x]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tr = o;\n\t\t}\n\t});\n\treturn r;\n}\n","export default (test, root) => {\n\treturn root && test instanceof root;\n};\n","// Pubsub extension\n// A contructor superclass for adding event menthods, on, off, emit.\nimport setImmediate from '../time/setImmediate.js';\n\nconst separator = /[\\s\\,]+/;\n\nexport default function() {\n\n\t// If this doesn't support getPrototype then we can't get prototype.events of the parent\n\t// So lets get the current instance events, and add those to a parent property\n\tthis.parent = {\n\t\tevents: this.events,\n\t\tfindEvents: this.findEvents,\n\t\tparent: this.parent,\n\t\tutils: this.utils\n\t};\n\n\tthis.events = {};\n\n\tthis.off = off;\n\tthis.on = on;\n\tthis.emit = emit;\n\tthis.emitAfter = emitAfter;\n\tthis.findEvents = findEvents;\n\n\treturn this;\n}\n\n\n// On, subscribe to events\n// @param evt   string\n// @param callback  function\nfunction on(evt, callback) {\n\n\tif (callback && typeof (callback) === 'function') {\n\t\tevt.split(separator).forEach(name => {\n\t\t\t// Has this event already been fired on this instance?\n\t\t\tthis.events[name] = [callback].concat(this.events[name] || []);\n\t\t});\n\t}\n\n\treturn this;\n}\n\n\n// Off, unsubscribe to events\n// @param evt   string\n// @param callback  function\nfunction off(evt, callback) {\n\n\tthis.findEvents(evt, function(name, index) {\n\t\tif (!callback || this.events[name][index] === callback) {\n\t\t\tthis.events[name][index] = null;\n\t\t}\n\t});\n\n\treturn this;\n}\n\n// Emit\n// Triggers any subscribed events\nfunction emit(evt, ...args) {\n\n\t// Append the eventname to the end of the arguments\n\targs.push(evt);\n\n\t// Handler\n\tvar handler = function(name, index) {\n\n\t\t// Replace the last property with the event name\n\t\targs[args.length - 1] = (name === '*' ? evt : name);\n\n\t\t// Trigger\n\t\tthis.events[name][index].apply(this, args);\n\t};\n\n\t// Find the callbacks which match the condition and call\n\tvar _this = this;\n\twhile (_this && _this.findEvents) {\n\n\t\t// Find events which match\n\t\t_this.findEvents(evt + ',*', handler);\n\t\t_this = _this.parent;\n\t}\n\n\treturn this;\n}\n\n// Easy functions\nfunction emitAfter() {\n\tvar _this = this;\n\tvar args = arguments;\n\tsetImmediate(function() {\n\t\t_this.emit.apply(_this, args);\n\t});\n\n\treturn this;\n}\n\nfunction findEvents(evt, callback) {\n\n\tvar a = evt.split(separator);\n\n\tfor (var name in this.events) {if (this.events.hasOwnProperty(name)) {\n\n\t\tif (a.indexOf(name) > -1) {\n\n\t\t\tthis.events[name].forEach(triggerCallback.bind(this, name, callback));\n\t\t}\n\t}}\n}\n\nfunction triggerCallback(name, callback, handler, i) {\n\t// Does the event handler exist?\n\tif (handler) {\n\t\t// Emit on the local instance of this\n\t\tcallback.call(this, name, i);\n\t}\n}\n","export default window.setImmediate || (cb => setTimeout(cb, 0));\n","define([\n\t'../utils/PeerConnection'\n],function(PeerConnection){\n\tvar pc, channel;\n\ttry{\n\t\t// raises exception if createDataChannel is not supported\n\t\tpc = new PeerConnection( {\"iceServers\": [{\"url\": \"stun:localhost\"}] });\n\t\tchannel = pc.createDataChannel('supportCheck', {reliable: false});\n\t\tchannel.close();\n\t\tpc.close();\n\t} catch(e) {}\n\n\treturn {\n\t\trtc : !!pc,\n\t\tdatachannel : !!channel\n\t};\n});","'use strict';\n\n// PeerJS\n// WebRTC Client Controler\n// @author Andrew Dodson (@mr_switch)\n// @since July 2012\n//\n\nimport Events from 'tricks/object/pubsub';\nimport extend from 'tricks/object/extend';\nimport featureDetect from './lib/featureDetect';\nimport Socket from './models/socket';\nimport Presence from './models/presence';\nimport Threads from './models/threads';\nimport Stream from './models/stream';\nimport Files from './models/files';\nimport Localmedia from './models/localmedia';\n\nlet STUN_SERVER = \"stun:stun.l.google.com:19302\";\nlet peer = Object.create(new Events());\n\nextend(peer, {\n\n\t// Defaults\n\tstun_server : STUN_SERVER,\n\n\t// DataChannel\n\tsupport : featureDetect,\n});\n\n// Expose external\nwindow.peer = peer;\n\n// Extend with the Web Sockets methods: connect(), send()\nSocket.call(peer);\n\n// Presence\n// Tag the current session with a unique identifier so that others can be notified about your presense and you can be notified about others\nPresence.call(peer);\n\n// Extend with the thread management: thread(), threads{}\nThreads.call(peer);\n\n// Extend with stream management: stream(), streams{}\nStreams.call(peer);\n\n// Extend with local Media\nLocalMedia.call(peer);\n\n// Extend with File Transfer\n// Files.call(peer);\n\n// BeforeUnload\nwindow.addEventListener('beforeunload', () => {\n\t// Tell everyone else of the session close.\n\tpeer.disconnect();\n});\n","//\n// File\n// Make available a link to stream file/blob artifacts\n//\n\ndefine([\n\n], function(){\n\n\n\treturn function(){\n\n\t\tvar self = this;\n\n\n\t\tvar chunkLength = 1000;\n\n\t\t// Extend the peer object\n\t\t// Sends the current file to another peer\n\n\t\tthis.sendFile = function(file, to){\n\n\t\t\tvar reader = new window.FileReader();\n\n\t\t\treader.onload = onReadAsDataURL;\n\n\t\t\treader.readAsDataURL(file);\n\n\t\t\tvar data = {\n\t\t\t\tto : to,\n\t\t\t\ttype : 'file:progress'\n\t\t\t};\n\n\t\t\tfunction onReadAsDataURL(event, text, index){\n\n\t\t\t\tif( event ){\n\t\t\t\t\ttext = event.target.result;\n\t\t\t\t}\n\n\t\t\t\tdata.index = +index||0;\n\n\t\t\t\tif (text.length > chunkLength) {\n\t\t\t\t\tdata.message = text.slice(0, chunkLength); // getting chunk using predefined chunk length\n\t\t\t\t} else {\n\t\t\t\t\tdata.message = text;\n\t\t\t\t\tdata.last = true;\n\t\t\t\t}\n\n\t\t\t\tself.send(data); // use JSON.stringify for chrome!\n\n\t\t\t\tvar remainingDataURL = text.slice(data.message.length);\n\n\t\t\t\tif (remainingDataURL.length){\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tonReadAsDataURL(null, remainingDataURL); // continue transmitting\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tvar files = {};\n\n\t\t//\n\t\t// Listen to incoming files\n\t\t//\n\t\tthis.on('file:progress', function(data){\n\n\t\t\t// Stick the pieces of the file back together\n\t\t\tfiles[data.id] = files[data.id] || [];\n\t\t\tfiles[data.id][data.index] = data.message;\n\n\t\t});\n\n\t};\n\n});\n","//\n// localMedia\n//\ndefine([\n\t'../utils/getUserMedia'\n], function(\n\tgetUserMedia\n){\n\n\n\treturn function(){\n\n\t\t//\n\t\t// LocalMedia\n\t\t// \n\t\tthis.localmedia = null;\n\n\t\t//\n\t\t// AddMedia\n\t\t//\n\t\tthis.addMedia = function(successHandler, failHandler){\n\n\t\t\tvar self = this;\n\n\n\t\t\t// Create a success callback\n\t\t\t// Fired when the users camera is attached\n\t\t\tvar _success = function(stream){\n\n\t\t\t\t// Attach stream\n\t\t\t\tself.localmedia = stream;\n\n\t\t\t\t// listen for change events on this stream\n\t\t\t\tstream.addEventListener('ended', function(){\n\t\t\t\t\t// Detect the change\n\t\t\t\t\tif( !self.localmedia || self.localmedia === stream ){\n\t\t\t\t\t\tself.emit('localmedia:disconnect', stream);\n\t\t\t\t\t\tself.localmedia = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif(successHandler){\n\t\t\t\t\tsuccessHandler(stream);\n\t\t\t\t}\n\n\t\t\t\t// Vid onload doesn't seem to fire\n\t\t\t\tself.emit('localmedia:connect',stream);\n\n\t\t\t};\n\n\t\t\t//\n\t\t\t// Has the callback been replaced with a stream\n\t\t\t//\n\t\t\tif(successHandler instanceof EventTarget){\n\n\t\t\t\t// User aded a media stream\n\t\t\t\t_success(successHandler);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Do we already have an open stream?\n\t\t\telse if(this.localmedia){\n\t\t\t\tif(successHandler){\n\t\t\t\t\tsuccessHandler(this.localmedia);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\n\t\t\t// Call it?\n\t\t\tgetUserMedia({audio:true,video:true}, _success, function(e){\n\t\t\t\t// Trigger a failure\n\t\t\t\tself.emit('localmedia:failed', e);\n\t\t\t\tfailHandler();\n\t\t\t});\n\n\n\t\t\treturn this;\n\t\t};\n\t};\n});","//\n// Provide a mechanism for monitoring peer presence\n//\n\ndefine(function(){\n\n\n\treturn function(){\n\n\t\t/////////////////////////////////////\n\t\t// TAG / WATCH LIST\n\t\t//\n\t\tthis.tag = function(data){\n\n\t\t\tif(!(data instanceof Array)){\n\t\t\t\tdata = [data];\n\t\t\t}\n\n\t\t\tthis.send('presence:tag', {data:data} );\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t//\n\t\t// Add and watch personal identifications\n\t\t//\n\t\tthis.watch = function(data){\n\n\t\t\tif(!(data instanceof Array)){\n\t\t\t\tdata = [data];\n\t\t\t}\n\n\t\t\tthis.send('presence:watch', {to:data} );\n\n\t\t\treturn this;\n\t\t};\n\t};\n});","//\n// Web Socket\n// Socket creates a send/receive protocol with the server\n// Currently this abstracts Socket.IO\n//\ndefine([\n\t'../utils/getScript'\n], function(\n\tgetScript\n){\n\n\tvar callbacks = [];\n\n\n\treturn function(){\n\n\t\tvar self = this;\n\n\t\t//\n\t\t// Initiate the socket connection\n\t\t//\n\t\tthis.init = function(ws, callback){\n\n\n\t\t\t//\n\t\t\tvar connected;\n\n\t\t\t// What happens on connect\n\t\t\tvar onload = function(){\n\n\t\t\t\tif(connected){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconnected = false;\n\n\t\t\t\t// Connect to the socket\n\t\t\t\tsocket = io.connect( ws );\n\n\t\t\t\tconsole.log(socket.socket.sessionid);\n\n\t\t\t\t// Define an message handling\n\t\t\t\tsocket.on('message', function(data){\n\n\t\t\t\t\t// Deserialize\n\t\t\t\t\tdata = JSON.parse(data);\n\n\t\t\t\t\t// Look for callbacks\n\t\t\t\t\tif(\"callback_response\" in data){\n\t\t\t\t\t\tvar i = data.callback_response;\n\t\t\t\t\t\tdelete data.callback_response;\n\t\t\t\t\t\tcallbacks[i](data);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tself.emit.call(self, data.type, data, function(o){\n\t\t\t\t\t\t// if callback was defined, lets send it back\n\t\t\t\t\t\tif(\"callback_id\" in data){\n\t\t\t\t\t\t\to.to = data.from;\n\t\t\t\t\t\t\to.callback_response = data.callback_id;\n\t\t\t\t\t\t\tsocket.send(JSON.stringify(o));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t// Load SocketIO if it doesn't exist\n\t\t\tif(typeof(io)==='undefined'){\n\t\t\t\tgetScript((ws||'') + \"/socket.io/socket.io.js\", onload);\n\t\t\t}\n\n\n\t\t\t// Loaded\n\t\t\tif(callback){\n\t\t\t\tthis.one('socket:connect', callback);\n\t\t\t}\n\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t// Disconnect\n\n\t\tthis.disconnect = function(){\n\t\t\tif(socket){\n\t\t\t\tsocket.disconnect();\n\t\t\t}\n\t\t};\n\n\n\t\t//\n\t\t// Send information to the socket\n\t\t//\n\t\tthis.send = function(name, data, callback){\n\n\t\t\t//\n\t\t\tif (typeof(name) === 'object'){\n\t\t\t\tcallback = data;\n\t\t\t\tdata = name;\n\t\t\t\tname = data.type;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdata.type = name;\n\t\t\t}\n\n\t\t\tvar callback_id;\n\n\n\t\t\t// Add callback\n\t\t\tif(callback){\n\t\t\t\t// Count\n\t\t\t\tdata.callback_id = callbacks.length;\n\t\t\t\tcallbacks.push(callback);\n\t\t\t}\n\n\t\t\tvar action = function(){\n\t\t\t\tconsole.log(\"sending:\", data);\n\t\t\t\tsocket.send(JSON.stringify(data));\n\t\t\t};\n\n\t\t\tif(this.id){\n\t\t\t\taction();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tself.one('socket:connect', action);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\n\t\tself.one('socket:connect', function(e){\n\t\t\tself.id = e.id;\n\t\t});\n\n\n\t};\n});","//\n// Stream\n// Create a new PeerConnection\n//\n\n\ndefine([\n\t'../utils/PeerConnection',\n\t'../utils/RTCSessionDescription',\n\n\t'../utils/extend',\n\t'../utils/merge',\n\t'../utils/isEqual',\n\t'../utils/events'\n\n], function(\n\n\tPeerConnection,\n\tRTCSessionDescription,\n\n\textend,\n\tmerge,\n\tisEqual,\n\tEvents\n\n){\n\n\t// Default Constraints\n\tvar default_constraints = {\n\t\tvideo : false\n\t};\n\n\n\tvar config = { 'optional': [], 'mandatory': {\n\t\t\t\t\t'OfferToReceiveAudio': true,\n\t\t\t\t\t'OfferToReceiveVideo': true }};\n\n\tvar media;\n\n\n\n\t// Extend our Global object with the stream methods, collections and listeners\n\n\treturn function(){\n\n\t\t// A collection of Peer Connection streams\n\n\t\tthis.streams = {};\n\n\n\t\t// Stream\n\t\t// Establishes a connection with a user\n\n\t\tthis.stream = function( id, constraints, offer ){\n\n\t\t\tconsole.log(\"stream\", arguments);\n\n\t\t\tif(!id){\n\t\t\t\tthrow 'streams(): Expecting an ID';\n\t\t\t}\n\t\t\t\n\t\t\t// Does this stream exist?\n\t\t\tvar stream = this.streams[id];\n\n\t\t\tif(!stream){\n\n\t\t\t\t// Create a new stream\n\t\t\t\tstream = this.streams[id] = Stream( id, constraints, this.stun_server, this );\n\n\t\t\t\t// Update an existing stream with fresh constraints\n\t\t\t\tif(constraints){\n\t\t\t\t\tstream.setConstraints( constraints );\n\t\t\t\t}\n\n\t\t\t\t// Output pupblished events from this stream\n\t\t\t\tstream.on('*', this.emit.bind(this) );\n\n\t\t\t\t// Control\n\t\t\t\t// This should now work, will have to reevaluate\n\t\t\t\tthis.on('localmedia:connect', stream.addStream);\n\t\t\t\tthis.on('localmedia:disconnect', stream.removeStream);\n\n\t\t\t\t//\n\t\t\t\t// Add the current Stream\n\t\t\t\tif(this.localmedia){\n\t\t\t\t\tstream.addStream(this.localmedia);\n\t\t\t\t}\n\n\t\t\t\t// intiiate the PeerConnection controller\n\t\t\t\t// Add the offer to the stream\n\t\t\t\tstream.open(offer || null);\n\n\t\t\t\treturn stream;\n\t\t\t}\n\n\t\t\telse if(constraints){\n\n\t\t\t\t// Update an existing stream with fresh constraints\n\t\t\t\tstream.setConstraints( constraints );\n\t\t\t}\n\t\t\telse if(offer!==undefined){\n\t\t\t\tstream.open( offer );\n\t\t\t}\n\n\t\t\treturn stream;\n\t\t};\n\n\n\n\n\n\t\t//////////////////////////////////////////////////\n\t\t// CHANNEL MESSAGING\n\t\t//////////////////////////////////////////////////\n\n\t\t// Store the socket send function\n\t\tvar socketSend = this.send;\n\n\t\t// Change it\n\t\tthis.send = function(name, data, callback){\n\n\t\t\tif(typeof name === 'object'){\n\t\t\t\tcallback = data;\n\t\t\t\tdata = name;\n\t\t\t\tname = data.type;\n\t\t\t}\n\n\t\t\tvar recipient = data.to,\n\t\t\t\tstream = this.streams[recipient];\n\n\t\t\tif( recipient && stream && stream.channel && stream.channel.readyState===\"open\"){\n\t\t\t\tif(name){\n\t\t\t\t\tdata.type = name;\n\t\t\t\t}\n\t\t\t\tvar str = JSON.stringify(data);\n\t\t\t\ttry{\n\t\t\t\t\tstream.channel.send(str);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch(e){\n\n\t\t\t\t\t// Other party could have disappeared\n\t\t\t\t\t// code: 19\n\t\t\t\t\t// message: \"Failed to execute 'send' on 'RTCDataChannel': Could not send data\"\n\t\t\t\t\t// name: \"NetworkError\"\n\n\t\t\t\t\tstream.channel = null;\n\n\t\t\t\t\t// Retrigger the stream channel creation\n\n\t\t\t\t\tthis.stream( recipient, null, null );\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Else fallback to the socket method\n\t\t\tsocketSend.call(this, name, data, callback);\n\t\t};\n\n\n\n\n\t\t//////////////////////////////////////////////////\n\t\t// STREAMS\n\t\t//////////////////////////////////////////////////\n\n\n\t\t// stream:connect\n\t\t// pass through any stream connection events\n\n\t\tthis.on('stream:connect, stream:change, stream:constraints', function( e ){\n\n\t\t\t// What has changed\n\t\t\tvar constraints = {};\n\n\t\t\t// we have information on what the remote constraints are\n\t\t\tif( e.remote ){\n\t\t\t\tconstraints.remote = merge( default_constraints, e.remote );\n\t\t\t}\n\t\t\t// We have the local constraints\n\t\t\t// Let also check that this has no-from field\n\t\t\tif( e.local && !e.from ){\n\t\t\t\tconstraints.local = merge( default_constraints, e.local );\n\t\t\t}\n\n\t\t\t// Create/Update the stream with the constraints offered.\n\t\t\tthis.stream( e.from || e.id, constraints );\n\n\t\t});\n\n\n\n\n\t\t// stream:offer\n\t\t// A client has sent a Peer Connection Offer\n\t\t// An Offer Object:\n\t\t//  -  string: SDP packet, \n\t\t//  -  string array: contraints\n\n\t\tthis.on('stream:offer, stream:makeoffer', function(e){\n\n\t\t\t// Creates a stream:answer event\n\t\t\tthis.stream( e.from, null, e.data || null );\n\n\t\t});\n\n\n\n\t\t//\n\t\t// stream:answer\n\t\t// \n\t\tthis.on('stream:answer', function(e){\n\n\t\t\tconsole.log(\"on:answer: Answer recieved, connection created\");\n\t\t\tthis.streams[e.from].pc.setRemoteDescription( new RTCSessionDescription( e.data ) );\n\n\t\t});\n\n\n\n\t\t// \n\t\t// Relay ice Candidates\n\t\t//\n\n\t\tthis.on('stream:candidate', function(e){\n\n\t\t\tvar uid = e.from,\n\t\t\t\tdata = e.data,\n\t\t\t\tstream = this.streams[uid];\n\n\t\t\tif(!stream){\n\t\t\t\tconsole.error(\"Candidate needs initiation\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar candidate = new RTCIceCandidate({\n\t\t\t\tsdpMLineIndex\t: data.label,\n\t\t\t\tcandidate\t\t: data.candidate\n\t\t\t});\n\n\t\t\ttry{\n\t\t\t\tstream.pc.addIceCandidate(candidate);\n\t\t\t}\n\t\t\tcatch(err){\n\t\t\t\tconsole.error('Failed to set iceCandidate');\n\t\t\t\tconsole.error( candidate );\n\t\t\t\tconsole.error( err );\n\t\t\t}\n\t\t});\n\n\n\t\t// Listen to change to the local media, and remove it streams if this occurs\n\n\t\tthis.on('localmedia:disconnect', function(mediastream){\n\t\t\t// Loop through streams and call removeStream\n\t\t\tfor(var x in this.streams){\n\t\t\t\tthis.streams[x].pc.removeStream(mediastream);\n\t\t\t}\n\t\t});\n\n\n\t\t// Channels\n\t\tthis.on('channel:connect', function(e){\n\t\t\t//\n\t\t\t// Process \n\t\t\t// console.log('channel:connect',e);\n\t\t});\n\n\t\t// \n\t\tthis.on('channel:message', function(data){\n\n\t\t\tif(\"callback_response\" in data){\n\t\t\t\tvar i = data.callback_response;\n\t\t\t\tdelete data.callback_response;\n\t\t\t\tthis.callback[i].call(peer, data);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar type = data.type;\n\n\t\t\tthis.emit(type, data, function(o){\n\t\t\t\t// if callback was defined, lets send it back\n\t\t\t\tif(\"callback\" in data){\n\t\t\t\t\to.to = data.from;\n\t\t\t\t\to.callback_response = data.callback;\n\t\t\t\t\tthis.send(o);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t};\n\n\n\n\n\t// ////////////////////////////////////////////////////////////\n\t//\n\t//\n\t// Individual stream controller\n\t//\n\t//\n\t// ////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n\n\n\tfunction Stream( id, constraints, STUN_SERVER, peer ){\n\n\t\t// Operations\n\t\t// Once the RTCPeerConnection object has been initialized, for every call to createOffer, setLocalDescription, createAnswer and setRemoteDescription; execute the following steps:\n\t\t// Append an object representing the current call being handled (i.e. function name and corresponding arguments) to the operations array.\n\t\t// If the length of the operations array is exactly 1, execute the function from the front of the queue asynchronously.\n\t\t// When the asynchronous operation completes (either successfully or with an error), remove the corresponding object from the operations array. \n\t\t//  - After removal, if the array is non-empty, execute the first object queued asynchronously and repeat this step on completion.\n\n\n\t\tvar operations = [];\n\t\tfunction operation(func){\n\n\t\t\t// Add operations to the list\n\t\t\tif(func){\n\t\t\t\toperations.push(func);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tconsole.log(\"STATE:\", pc.signalingState);\n\t\t\t}\n\n\t\t\t// Are we in a stable state?\n\t\t\tif(pc.signalingState==='stable'){\n\n\t\t\t\t// Pop the operation off the front.\n\t\t\t\tvar op = operations.shift();\n\t\t\t\tif(op){\n\t\t\t\t\top();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tconsole.log(\"PENDING:\", operations);\n\t\t\t}\n\t\t}\n\n\n\t\tvar pc,\n\t\t\tstream = new Events();\n\n\t\t// Creating an offer is a little fraught with dnager if the other party does so too\n\t\t// To mitigate the problems lets turn on a flag when the master client (determined arbitarily from session ID)\n\t\t// Needs a negotiation that they wont process offers themselves\n\t\tvar MASTER = id < peer.id;\n\n\t\t// Null\n\t\tstream.channel = null;\n\n\n\t\t// Default constraints\n\t\tstream.constraints = {\n\t\t\tremote : {},\n\t\t\tlocal : {}\n\t\t};\n\n\n\t\t// listen to stream change events\n\t\tstream.setConstraints = function(constraints){\n\n\t\t\t// If changes to the local constraint has occured\n\t\t\t// deliver these to the other peer\n\t\t\tvar changed;\n\t\t\tif( constraints.local && !isEqual( stream.constraints.local, constraints.local ) ){\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\t\n\t\t\t// Update constraints\n\t\t\textend(stream.constraints, constraints||{});\n\n\t\t\tconsole.log( stream.constraints );\n\n\t\t\t// Trigger Constraints/Media changed listener\n\t\t\ttoggleLocalStream();\n\n\t\t\t// Has the local constraints changed?\n\t\t\tif(\tchanged ){\n\t\t\t\t// Tell the thirdparty about it\n\t\t\t\tpeer.send({\n\t\t\t\t\ttype: 'stream:constraints',\n\t\t\t\t\tremote : stream.constraints.local,\n\t\t\t\t\tto : id\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\n\t\t// Listen out for stream:disconnected\n\t\t// this is triggered by the ICE candidate state change\n\t\t// It can be used to infer that the connection has dissappeared\n\t\t// We can use it to disable a media stream\n\t\tstream.on('stream:disconnected', function(){\n\n\t\t\t// Has a remotemedia value been proffered\n\t\t\tif( stream.remotemedia ){\n\n\t\t\t\t// Mimic the removal of the media\n\t\t\t\tstream.emit('media:disconnect', stream.remotemedia);\n\n\t\t\t\t// Reinstate it if the connection is reestablished\n\t\t\t\tstream.one('stream:connected', function(){\n\t\t\t\t\tstream.emit('media:connect', stream.remotemedia);\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n\n\t\t// Peer Connection\n\t\t// Initiate a local peer connection handler\n\t\tvar pc_config = {\"iceServers\": [{\"url\": STUN_SERVER}]},\n\t\t\tpc_constraints = {\"optional\": [{\"DtlsSrtpKeyAgreement\": true}]};\n//\t\t\t\tstun = local ? null : Peer.stun_server;\n\n\t\ttry{\n\t\t\t//\n\t\t\t// Reference this connection\n\t\t\t//\n\t\t\tstream.pc = pc = new PeerConnection(pc_config, pc_constraints);\n\n\t\t\tpc.onicecandidate = function(e){\n\t\t\t\tvar candidate = e.candidate;\n\t\t\t\tif(candidate){\n\t\t\t\t\tpeer.send({\n\t\t\t\t\t\ttype : 'stream:candidate',\n\t\t\t\t\t\tdata : {\n\t\t\t\t\t\t\tlabel: candidate.label||candidate.sdpMLineIndex,\n\t\t\t\t\t\t\tcandidate: candidate.toSdp ? candidate.toSdp() : candidate.candidate\n\t\t\t\t\t\t},\n\t\t\t\t\t\tto : id\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t}catch(e){\n\t\t\tconsole.error(\"PeerJS: Failed to create PeerConnection, exception: \" + e.message);\n\t\t\treturn stream;\n\t\t}\n\n\n\t\tpc.onsignalingstatechange = function(e){\n\t\t\toperation();\n\t\t};\n\n\n\t\tpc.oniceconnectionstatechange = function(e){\n\t\t\tconsole.warn(\"ICE-CONNECTION-STATE-CHANGE \" + pc.iceConnectionState);\n\n\t\t\t// Determine whether the third party has ended their connection\n\t\t\tstream.emit('stream:'+pc.iceConnectionState, {\n\t\t\t\tfrom : id\n\t\t\t});\n\t\t};\n\n\n\t\t//pc.addEventListener(\"addstream\", works in Chrome\n\t\t//pc.onaddstream works in FF and Chrome\n\t\tpc.onaddstream = function(e){\n\t\t\te.from = id;\n\t\t\tstream.emit('media:connect', e);\n\n\t\t\tstream.remotemedia = e;\n\n\n\t\t\t// Listen to ended event\n\t\t/*\te.stream.addEventListener('ended', function(){\n\t\t\t\talert('ended');\n\t\t\t});*/\n\n\n\t\t\t// Check to see if they are accepting video\n\t\t\ttoggleLocalStream();\n\t\t};\n\n\t\t// pc.addEventListener(\"removestream\", works in Chrome\n\t\t// pc.onremovestream works in Chrome and FF.\n\t\tpc.onremovestream = function(e){\n\n\t\t\tremotemedia = null;\n\t\t\te.from = id;\n\t\t\tstream.emit('media:disconnect', e);\n\n\t\t\t// Check to see if they are accepting video\n\t\t\ttoggleLocalStream();\n\t\t};\n\n\t\tpc.ondatachannel = function(e){\n\t\t\tstream.channel = e.channel;\n\t\t\tsetupDataChannel(e.channel);\n\t\t};\n\n\t\tpc.onnegotiationneeded = function(e){\n\n\t\t\t// Has the signalling state changed?\n\n\t\t\tif( pc.signalingState === 'closed' ){\n\t\t\t\tconsole.warn('signallingState closed');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(MASTER){\n\n\t\t\t\t// Create an offer\n\t\t\t\tpc.createOffer(function(session){\n\t\t\t\t\toperation(function(){\n\t\t\t\t\t\tpc.setLocalDescription(session, function(){\n\t\t\t\t\t\t\tpeer.send({\n\t\t\t\t\t\t\t\ttype : \"stream:offer\",\n\t\t\t\t\t\t\t\tto : id,\n\t\t\t\t\t\t\t\tdata : pc.localDescription\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, errorHandler);\n\t\t\t\t\t});\n\t\t\t\t}, null, config);\n\n\t\t\t}\n\n\t\t\telse{\n\n\t\t\t\t// Ask the other client to make the offer\n\t\t\t\tpeer.send({\n\t\t\t\t\ttype : \"stream:makeoffer\",\n\t\t\t\t\tto : id\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t};\n\n\n\t\tstream.addStream = function(_media){\n\t\t\tmedia = _media;\n\t\t\ttoggleLocalStream();\n\t\t};\n\n\t\tstream.removeStream = function(){\n\t\t\tmedia = null;\n\t\t\ttoggleLocalStream();\n\t\t};\n\n\n\t\tstream.open = function(offer){\n\n\t\t\t// Is this an offer or an answer?\n\t\t\t// No data is needed to make an offer\n\t\t\t// Making an offer?\n\t\t\tif(!offer){\n\n\t\t\t\t// Trigger onnegotiation needed\n\t\t\t\tif( MASTER && !stream.channel ){\n\t\t\t\t\t// Create a datachannel\n\t\t\t\t\t// This initiates the onnegotiationneeded event\n\t\t\t\t\tstream.channel = pc.createDataChannel('data');\n\t\t\t\t\tsetupDataChannel(stream.channel);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// trigger the fallback for on negotiation needed\n\t\t\t\t\toperation(pc.onnegotiationneeded);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// No, we're processing an offer to make an answer then\n\t\t\t// If this client has protected itself then the third party clients offer is disgarded\n\t\t\telse{ // if(!PROTECTED){\n\n\t\t\t\t// Set the remote offer information\n\t\t\t\tpc.setRemoteDescription(new RTCSessionDescription(offer), function(){\n\n\t\t\t\t\tif( pc.signalingState === 'closed' ){\n\t\t\t\t\t\tconsole.warn(\"signalingState closed: during setRemoteDescription\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tpc.createAnswer(function(session){\n\t\t\t\t\t\tconsole.log(\"pc.signalingState\",pc.signalingState);\n\n\t\t\t\t\t\tif(pc.signalingState === 'closed'){\n\t\t\t\t\t\t\tconsole.warn(\"signalingState closed: after createAnswer\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpc.setLocalDescription(session, function(){\n\t\t\t\t\t\t\tpeer.send({\n\t\t\t\t\t\t\t\ttype : \"stream:answer\",\n\t\t\t\t\t\t\t\tto : id,\n\t\t\t\t\t\t\t\tdata : pc.localDescription\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},errorHandler);\n\t\t\t\t\t}, null, config);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\n\t\treturn stream;\n\n\t\tfunction errorHandler(e){\n\t\t\tconsole.error(\"SET Description failed triggered:\",e);\n\t\t}\n\n\t\t//\n\t\tfunction setupDataChannel(channel){\n\n\t\t\tconsole.debug(\"DATACHANNEL CREATED\", channel);\n\n\t\t\t// Broadcast\n\t\t\tchannel.onopen = function(e){\n\t\t\t\tstream.emit(\"channel:connect\", {\n\t\t\t\t\ttype : 'channel:connect',\n\t\t\t\t\tid : id,\n\t\t\t\t\tfrom : id,\n\t\t\t\t\tto : peer.id,\n\t\t\t\t\ttarget : e\n\t\t\t\t});\n\t\t\t};\n\t\t\tchannel.onmessage = function(e){\n\n\t\t\t\tvar data = JSON.parse(e.data);\n\t\t\t\tdata.from = id;\n\t\t\t\tdata.to = peer.id;\n\t\t\t\tdata.target = e;\n\n\t\t\t\tstream.emit(\"channel:message\", data);\n\t\t\t};\n\t\t\tchannel.onerror = function(e){\n\t\t\t\te.id = id;\n\t\t\t\tstream.emit(\"channel:error\", e);\n\t\t\t};\n\t\t}\n\n\t\tfunction toggleLocalStream(){\n\n\t\t\tif(!pc || pc.readyState==='closed'){\n\t\t\t\tconsole.log(\"PC:connection closed, can't add stream\");\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\t// Do the constraints allow for media to be added?\n\t\t\tif(!stream.constraints.local.video||!stream.constraints.remote.video||!media){\n\n\t\t\t\t// We should probably remove the stream here\n\t\t\t\tpc.getLocalStreams().forEach(function(media){\n\t\t\t\t\toperation(function(){\n\t\t\t\t\t\tconsole.log(\"PC:removing local media\", media);\n\t\t\t\t\t\tpc.removeStream(media);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconsole.log(\"PC:adding local media\");\n\n\t\t\t// Has the media already been added?\n\t\t\tvar exit = false;\n\t\t\tpc.getLocalStreams().forEach(function(_media){\n\t\t\t\tif(media === _media){\n\t\t\t\t\texit = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif(exit){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set up listeners when tracks are removed from this stream\n\t\t\t// Aka if the streams loses its audio/video track we want this to update this peer connection stream\n\t\t\t// For some reason it doesn't... which is weird\n\t\t\t// TODO: remove the any tracks from the stream here if this is not a regular call.\n\t\t\toperation(function(){\n\t\t\t\t// We should probably remove the stream here\n\t\t\t\tconsole.log(\"Adding local stream\");\n\t\t\t\tpc.addStream(media);\n\t\t\t});\n\n\t\t\t// Add event listeners to stream\n\t\t\tmedia.addEventListener('addtrack', function(e){\n\t\t\t\t// reestablish a track\n\t\t\t\tconsole.log(e);\n\t\t\t\t// Swtich out current stream with new stream\n\t\t\t\t//var a = pc.getLocalStreams();\n\t\t\t\t//console.log(a);\n\t\t\t});\n\n\t\t\t// Remove track\n\t\t\tmedia.addEventListener('removetrack', function(e){\n\t\t\t\t//var a = pc.getLocalStreams();\n\t\t\t\tconsole.log(e);\n\t\t\t});\n\n\t\t}\n\t}\n\n\n});","//\n// Threads\n// Maintain a list of threads which a user is subscribed too\n//\ndefine([\n\t'../utils/extend'\n],\nfunction(\n\textend\n){\n\n\n\t// A thread is a collection of the following\n\n\tfunction Thread(id){\n\t\tthis.id = id;\n\t\tthis.constraints = {};\n\t\tthis.streams = {};\n\t\tthis.state = 'connect';\n\t}\n\n\n\t// Extention of the peer object\n\n\treturn function(){\n\n\t\t//\n\t\t// A collection of threads for which this user has connected\n\t\tthis.threads = {};\n\n\n\t\t//\n\t\t// Thread connecting/changeing/disconnecting\n\t\t// Control the participation in a thread, by setting the permissions which you grant the thread.\n\t\t// e.g. \n\t\t// thread( id string, Object[video:true] )  - send 'thread:connect'\t\t- connects this user to a thread. Broadcasts \n\t\t// thread( id string, Object[video:false] ) - send 'thread:change'\t\t- connects/selects this user to a thread\n\t\t// thread( id string, false )\t\t\t\t- send 'thread:disconnect'\t- disconnects this user from a thread\n\t\t//\n\t\t//\n\t\t// Typical preceeding flow: init\n\t\t// -----------------------------\n\t\t// 1. Broadcasts thread:connect + credentials - gets other members thread:connect (incl, credentials)\n\t\t// \n\t\t// 2. Receiving a thread:connect with the users credentials\n\t\t//\t\t- creates a peer connection (if preferential session)\n\t\t//\n\t\t//\t\t- taking the lowest possible credentials of both members decide whether to send camera*\n\t\t//\n\t\t// Thread:change\n\t\t// -----------------------------\n\t\t// 1. Updates sessions, updates other members knowledge of this client\n\t\t//\t\t- Broadcasts thread:change + new credentials to other members.\n\t\t//\t\t- ForEach peer connection which pertains to this session\n\t\t//\t\t\tFor all the threads which this peer connection exists in determine the highest possible credentials, e.g. do they support video\n\t\t//\t\t\tAdd/Remove remote + local video streams (depending on credentials). Should we reignite the Connection confifuration?\n\t\t//\t\t- This looks at all sessions in the thread and determines whether its saf\n\t\t//\n\t\tthis.thread = function(id, constraints){\n\n\t\t\tvar init = false;\n\n\t\t\tif( typeof(id) === \"object\" || !id ){\n\t\t\t\tif(!constraints){\n\t\t\t\t\tconstraints = id || {};\n\t\t\t\t}\n\n\t\t\t\t// Make up a new thread ID if one wasn't given\n\t\t\t\tid = (Math.random() * 1e18).toString(36);\n\t\t\t}\n\n\n\t\t\t// Get the thread\n\t\t\tvar thread = this.threads[id];\n\n\n\t\t\t// Type\n\t\t\tvar type;\n\n\n\t\t\t// INIT\n\t\t\t// Else intiiatlize the thread\n\t\t\tif(!thread){\n\n\t\t\t\t// Create the thread object\n\t\t\t\tthread = this.threads[id] =  new Thread(id);\n\t\t\t\tthread.constraints = constraints || {};\n\n\t\t\t\t// Response\n\t\t\t\ttype = \"thread:connect\";\n\n\t\t\t}\n\n\t\t\t// CHANGE constraints\n\t\t\telse if( constraints ){\n\n\t\t\t\t// If this had been deleted\n\t\t\t\tif(!thread.constraints){\n\t\t\t\t\t// reinstate it\n\t\t\t\t\tthread.constraints = {};\n\t\t\t\t}\n\n\t\t\t\t// Update thread constraints\n\t\t\t\textend( thread.constraints, constraints );\n\n\t\t\t\t// Response\n\t\t\t\ttype = \"thread:change\";\n\n\t\t\t}\n\n\t\t\t//\n\t\t\t// DISCONNECT\n\t\t\telse if( constraints === false ){\n\n\t\t\t\t// Update state\n\t\t\t\tthread.constraints = false;\n\t\t\t\ttype = \"thread:disconnect\";\n\t\t\t}\n\n\n\t\t\tif( type ){\n\n\t\t\t\tvar data = {\n\t\t\t\t\tthread : id,\n\t\t\t\t};\n\n\t\t\t\t// Constraints changed?\n\t\t\t\tif( constraints ){\n\t\t\t\t\tdata.constraints = thread.constraints;\n\t\t\t\t}\n\n\n\t\t\t\t// Connect to a messaging group\n\t\t\t\tthis.send(type, data);\n\n\t\t\t\t// Triggered locally\n\t\t\t\tthis.emit(type, data);\n\n\t\t\t}\n\n\n\t\t\treturn thread;\n\t\t};\n\n\n\n\t\t//\n\t\t// Thread:Connect (comms)\n\t\t// When a user B has joined a thread the party in that thread A is notified with a thread:connect Event\n\t\t// Party A replies with an identical thread:connect to party B (this ensures everyone connecting is actually online)\n\t\t// Party B does not reply to direct thread:connect containing a \"to\" field events, and the chain is broken.\n\t\t//\n\t\tthis.on('thread:connect, thread:change', function(e){\n\n\t\t\t// The incoming user\n\n\t\t\tvar remoteID = e.from;\n\n\t\t\tconsole.log(\"thread:change\", e);\n\n\n\t\t\t// Must include a thread id.\n\t\t\t// If this was triggered locally, it wont include the e.from field\n\n\t\t\tif ( !e.thread ){\n\t\t\t\t// this is nonsense\n\t\t\t\tthrow Error(\"thread:* event fired without a thread value\");\n\t\t\t}\n\n\t\t\t// Get or create a thread\n\t\t\t// But it could be that the thread was somehow removed.\n\n\t\t\tvar thread = this.thread(e.thread);\n\n\n\t\t\tif ( !remoteID ){\n\n\t\t\t\t// this is a local update\n\t\t\t\t// let all the streams in the thread know\n\t\t\t\tfor( remoteID in thread.streams ){\n\t\t\t\t\tupdatePeerConnection.call(this, remoteID);\n\t\t\t\t}\n\n\t\t\t\t// Lets not do anything.\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\t// Establish/Update a session for the thread\n\n\t\t\tif( !(remoteID in thread.streams) ){\n\n\t\t\t\t// Set the default\n\t\t\t\tthread.streams[remoteID] = e.constraints || {};\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// The stream object contains the constraints for that user\n\t\t\t\t// Lets apply the constraints from this connection too that user.\n\t\t\t\textend( thread.streams[remoteID], e.constraints || {} );\n\t\t\t}\n\n\n\t\t\t// Trigger a review of this peer connection\n\t\t\tupdatePeerConnection.call(this, remoteID);\n\n\n\t\t\t// SEND THREAD:CONNECT\n\t\t\t// Was this a direct message?\n\t\t\tif(!e.to){\n\t\t\t\t// Send a thread:connect back to the remote\n\t\t\t\tvar data = {\n\t\t\t\t\tto : remoteID,\n\t\t\t\t\tthread : thread.id,\n\t\t\t\t\tconstraints : thread.constraints\n\t\t\t\t};\n\t\t\t\tconsole.log(\"SEND\", JSON.stringify(data) );\n\t\t\t\tthis.send('thread:connect', data);\n\t\t\t}\n\t\t});\n\n\n\t\t// thread:disconnect\n\t\t// When a member disconnects from a thread we get a thread:disconnect event\n\n\t\tthis.on('thread:disconnect', function(e){\n\n\t\t\t// Get thread\n\t\t\tvar thread = this.threads[e.thread];\n\t\t\tvar remoteID;\n\n\t\t\t// Is from a remote peer\n\t\t\tif( \"from\" in e ){\n\t\t\t\t\n\t\t\t\tremoteID = e.from;\n\n\t\t\t\t// From a remote peer removing their thread connection\n\t\t\t\tif( remoteID in thread.streams ){\n\n\t\t\t\t\tdelete thread.streams[remoteID];\n\n\t\t\t\t\t// Clean up sessions\n\t\t\t\t\tupdatePeerConnection.call(this, remoteID);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// From the local peer, removing themselves from a thread\n\t\t\telse{\n\n\t\t\t\t// Loop through the thread streams\n\t\t\t\tfor( remoteID in threads.stream ){\n\n\t\t\t\t\t// Clean up peer connection\n\t\t\t\t\tupdatePeerConnection.call(this, remoteID);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t});\n\n\n\t\t// For all the active peers pertaining to multiple threads, determine whether the connection setting have changed.\n\t\t// \n\t\t// This is done my looping through all threads to find the session for a particular peer\n\t\t// Building a list of the maximum constraint connection requirements for that remote peer.\n\t\t// Whilst building a maximum constraints for the local peer for where the remote peer is in the same thread.\n\t\t// Trigger a stream:change event with the constraints from the aforementioned two maxiumm requirements\n\n\t\tfunction updatePeerConnection( remoteID ){\n\n\t\t\t// Placeholder to store the minimal requirement for this peer\n\n\t\t\tvar local = {},\n\t\t\t\tremote = {};\n\n\t\t\t// Start looping through the threads\n\t\t\t// And then the streams\n\n\t\t\tfor( var threadId in this.threads ){\n\n\t\t\t\tvar thread = this.threads[threadId];\n\t\t\t\tvar streams = thread.streams;\n\n\t\t\t\t// Is this peer not associated with the current thread\n\t\t\t\tif( !( remoteID in streams ) ){\n\t\t\t\t\t// Look at the next thread\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// REMOTE\n\t\t\t\textendProperties( remote, streams[remoteID] );\n\n\t\t\t\t// LOCAL\n\t\t\t\textendProperties( local, thread.constraints );\n\n\t\t\t}\n\n\n\t\t\t// Once all the stream credentials have been scooped up...\n\t\t\t// Emit a stream:change event\n\t\t\tthis.emit('stream:change',{\n\t\t\t\tid : remoteID,\n\t\t\t\tlocal : local,\n\t\t\t\tremote : remote\n\t\t\t});\n\t\t}\n\n\t};\n\n\n\tfunction extendProperties(a,b){\n\n\t\tif(!b){\n\t\t\treturn;\n\t\t}\n\n\t\tfor( var constraint in b ){\n\n\t\t\tvar value = b[constraint];\n\n\t\t\t// If the constraint is true\n\t\t\tif( value ){\n\n\t\t\t\t// Update a\n\t\t\t\ta[constraint] = value;\n\t\t\t}\n\t\t}\n\t}\n\n});"],"sourceRoot":"/source/"}